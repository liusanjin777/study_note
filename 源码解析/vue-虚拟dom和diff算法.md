# 虚拟dom、diff算法、vue3的优化

## 虚拟dom

### 为什么创建虚拟dom

- 创建一个空的div代价很大，会包含div的各种各样的属性。

### 虚拟dom是什么

虚拟dom就是创建一个对象，包含3个属性：

- tag：标签，也可以是一个组件或者一个函数
- props：标签上的属性和方法
- children：文本或者子dom，如果是文本的话就是一个字符串，如果是子dom就是一个数组

```js
// 表达方式
{
  tag:'div',
  props:{ id:'app', class:'container' },
  children: [
    { tag: 'h1', children:'test' }
  ]
}
```

在vue中里虚拟 DOM 的数据更新机制采用的是异步更新队列，会将变更后的虚拟dom装填进一个数据更新的异步队列

## diff算法

patch：新旧虚拟dom对比

### 执行时间

- 页面首次渲染时会调用一次patch并创建vnode，但是不会进行深层次的比较
- 组件数据发生变化的时候，会触发setter，然后通过Notify通知观察者`watcher`,对应的观察者会通知更新并执行更新函数，执行render函数来获取新的虚拟dom，然后执行patch（新旧虚拟dom对比），计算出最小的变化，根据这个变化去更新真实的dom

### 计算方法

vue和react使用diff算法的时候都遵循深度优先遍历，同层比较策略

1. diff过程会把同一层级、同一父节点的dom来进行比较，减少比较次数

2. 比较标签名：如果同一层级的标签名不同，那就直接移除老的虚拟dom，不用继续按照这个节点及以下的树状结构进行比较。
3. 比较key：如果标签名相同、key也相同，那就会认为是相同节点

#### key的作用

#### 不使用key或者采用数组的index作为key

当存在元素`[1, 2, 3, 4]`时，在`1`和`2`中间插入`5`元素，那么`1`不会重新渲染，但是`2，3，4`都会重新渲染  

因为在不使用 `key` 或者列表的 `index` 作为 `key` 的时候，每个元素对应的位置关系都是 index，上图中的结果直接导致我们插入的元素到后面的全部元素，对应的位置关系都发生了变更，所以全部都会执行更新操作

#### 使用key

在`1`和`2`中间插入`5`元素，只会添加节点`5`，不会重新渲染`2，3，4`

#### 总结

- 精确的找到相同节点，更高效的更新虚拟dom

## vue3的优化

- 事件缓存
- 添加静态标记
- 静态提升
- 使用最长递增子序列优化了对比流程

### 事件缓存

vue3在编译一个事件的时候，会先看看维护的缓存数组中有没有这个事件，如果有直接读取，如果没有就把这个事件存入缓存中

### 添加静态标记

```ts
export const enum PatchFlags {
  TEXT = 1 ,  // 动态文本节点
  CLASS = 1 << 1,  // 2   动态class
  STYLE = 1 << 2,  // 4   动态style
  PROPS = 1 << 3,  // 8   除去class/style以外的动态属性
  FULL_PROPS = 1 << 4,       // 16  有动态key属性的节点，当key改变时，需进行完整的diff比较
  HYDRATE_EVENTS = 1 << 5,   // 32  有监听事件的节点
  STABLE_FRAGMENT = 1 << 6,  // 64  一个不会改变子节点顺序的fragment (一个组件内多个根元素就会用fragment包裹)
  KEYED_FRAGMENT = 1 << 7,   // 128 带有key属性的fragment或部分子节点有key
  UNKEYEN_FRAGMENT = 1 << 8, // 256  子节点没有key的fragment
  NEED_PATCH = 1 << 9,       // 512  一个节点只会进行非props比较
  DYNAMIC_SLOTS = 1 << 10,   // 1024   动态slot
  HOISTED = -1,  // 静态节点 
  BAIL = -2      // 表示 Diff 过程中不需要优化
}
```

一个节点根据vue3编译后，patch过程中就会判断这个标记来diff优化流程，跳过一些静态节点对比

### 静态提升

在vue2中，触发更新的时候会将全部节点重新创建，而vue3会把不参与更新的元素保存下来，只创建一次，在后续的渲染中不停的复用

### 使用最长递增子序列

vue2中`updateChildren`会进行

- 头和头比
- 尾和尾比
- 头和尾比
- 尾和头比
- 都没有命中的对比

在 Vue3 里 `patchKeyedChildren` 为

- 头和头比

- 尾和尾比
- 基于最长递增子序列进行移动/添加/删除
