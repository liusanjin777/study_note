---
title: 事件循环和异步IO
date: 2021-12-24 16:28:25
tags: Node, 浏览器, js
---

## 浏览器事件循环和异步IO

### 事件循环

- 事件循环我们编写的js代码和浏览器或者Node之间的一个桥梁
- 浏览器的事件循环是一个我们编写的js代码和浏览器api调用（setTimeout/Ajax/监听事件等）的一个桥梁
- Node的事件循环是一个我们编写的js代码和系统调用（file system/ network）的一个桥梁

#### 进程和线程

- 进程---是计算机已经运行的程序；
- 线程---是操作系统能够运行调度的最小单位；每一个进程中，都会启动一个线程来执行程序中的代码
- 操作系统类似一个工厂
- 进程类似车间
- 线程类似工人

#### 事件循环的理解

- 浏览器在执行js代码时会创建一个用来执行函数的栈，当函数执行的时候会被压入到栈中，函数执行结束会被推出栈。
- 当运行代码时碰到回调函数（setTimeout等），setTiemout本身会立即执行，但是它的回调函数会被浏览器保存在其他地方，当delay时间到后，会被推进一个队列中。
- 当栈中的任务执行完毕，浏览器发现队列中有任务的时候，会被立即放入栈中执行，依次反复。
- 值得注意的是有两个队列，一个被用来放微任务，一个被用来放宏任务，浏览器会优先选择微任务，当微任务队列为空的时候，会选择宏任务。
- ![浏览器事件循环](https://s3.bmp.ovh/imgs/2021/12/42b26366603a6da5.webp)

## node事件循环

### node架构分析

- libua中主要维护了一个EventLoop和worker-threads （线程池）

### 阻塞io和非阻塞io

- 对文件的操作，是一个操作系统的系统调用（io系统，io是输入输出）
- 阻塞式调用：调用结果返回之前，当前线程处于阻塞态（cpu不会分配时间片）
- 非阻塞式调用：调用执行之后，当前线程不会停止执行
- 非阻塞式调用-轮询操作：为了知道是否读取到了完整的数据，我们需要频繁的去确定读取到的数据是否是完整的

### 阻塞和非阻塞，同步和异步的区别

- 阻塞和非阻塞一般是对被调用者来说的，被调用者（例如os）提供了这两种方式
- 同步和异步是对调用者来说的
- libuv采用非阻塞一般io的调用方式

### node事件循环的阶段

- timers阶段：用来执行timer(setTimeout,setInterval)的回调；
- I/O callbacks阶段：处理一些上一轮循环中少数未执行的I/O回调
- idle,prepare 阶段：仅node内部使用，我们用不到；
- poll阶段：获取新的I/O时间，适当的条件下node将阻塞在这里；是异步回调事件，除了setTimeout、setInterval、process.nextTick、Promise、setImmediate之外的事件
- check阶段：执行setImmediate()的回调；
- close callbacks 阶段：执行socket的close时间回调

#### 顺序

- nextTick queue的执行优先级大于others 微任务队列。
- 微任务执行>宏任务任务
- 同步执行代码执行优先级最高。
- 同一阶段或同一队列的执行，按先进先出的顺序执行。
- 代码的执行和代码所在的位置无关